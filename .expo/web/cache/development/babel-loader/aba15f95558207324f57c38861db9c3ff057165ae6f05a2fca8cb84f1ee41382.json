{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nvar _updatePushTokenAsync, _setAutoServerRegistrationEnabledAsync, _handlePersistedRegistrationInfoAsync;\nimport 'abort-controller/polyfill';\nimport { UnavailabilityError } from 'expo-modules-core';\nimport ServerRegistrationModule from \"./ServerRegistrationModule\";\nimport { addPushTokenListener } from \"./TokenEmitter\";\nimport getDevicePushTokenAsync from \"./getDevicePushTokenAsync\";\nimport { updateDevicePushTokenAsync as updateDevicePushTokenAsyncWithSignal } from \"./utils/updateDevicePushTokenAsync\";\nvar lastAbortController = null;\nfunction updatePushTokenAsync(_x) {\n  return (_updatePushTokenAsync = _updatePushTokenAsync || _asyncToGenerator(function* (token) {\n    var _lastAbortController;\n    (_lastAbortController = lastAbortController) == null ? void 0 : _lastAbortController.abort();\n    lastAbortController = new AbortController();\n    return yield updateDevicePushTokenAsyncWithSignal(lastAbortController.signal, token);\n  })).apply(this, arguments);\n}\nexport function setAutoServerRegistrationEnabledAsync(_x2) {\n  return (_setAutoServerRegistrationEnabledAsync = _setAutoServerRegistrationEnabledAsync || _asyncToGenerator(function* (enabled) {\n    var _lastAbortController2;\n    (_lastAbortController2 = lastAbortController) == null ? void 0 : _lastAbortController2.abort();\n    if (!ServerRegistrationModule.setRegistrationInfoAsync) {\n      throw new UnavailabilityError('ServerRegistrationModule', 'setRegistrationInfoAsync');\n    }\n    yield ServerRegistrationModule.setRegistrationInfoAsync(enabled ? JSON.stringify({\n      isEnabled: enabled\n    }) : null);\n  })).apply(this, arguments);\n}\nexport function __handlePersistedRegistrationInfoAsync(_x3) {\n  return (_handlePersistedRegistrationInfoAsync = _handlePersistedRegistrationInfoAsync || _asyncToGenerator(function* (registrationInfo) {\n    var _registration;\n    if (!registrationInfo) {\n      return;\n    }\n    var registration = null;\n    try {\n      registration = JSON.parse(registrationInfo);\n    } catch (e) {\n      console.warn('[expo-notifications] Error encountered while fetching registration information for auto token updates.', e);\n    }\n    if (!((_registration = registration) != null && _registration.isEnabled)) {\n      return;\n    }\n    try {\n      var latestDevicePushToken = yield getDevicePushTokenAsync();\n      yield updatePushTokenAsync(latestDevicePushToken);\n    } catch (e) {\n      console.warn('[expo-notifications] Error encountered while updating server registration with latest device push token.', e);\n    }\n  })).apply(this, arguments);\n}\nif (ServerRegistrationModule.getRegistrationInfoAsync) {\n  var _ref;\n  addPushTokenListener(function (_x4) {\n    return (_ref = _ref || _asyncToGenerator(function* (token) {\n      try {\n        var registrationInfo = yield ServerRegistrationModule.getRegistrationInfoAsync();\n        if (!registrationInfo) {\n          return;\n        }\n        var registration = JSON.parse(registrationInfo);\n        if (registration != null && registration.isEnabled) {\n          yield updatePushTokenAsync(token);\n        }\n      } catch (e) {\n        console.warn('[expo-notifications] Error encountered while updating server registration with latest device push token.', e);\n      }\n    })).apply(this, arguments);\n  });\n  ServerRegistrationModule.getRegistrationInfoAsync().then(__handlePersistedRegistrationInfoAsync);\n} else {\n  console.warn(\"[expo-notifications] Error encountered while fetching auto-registration state, new tokens will not be automatically registered on server.\", new UnavailabilityError('ServerRegistrationModule', 'getRegistrationInfoAsync'));\n}","map":{"version":3,"names":["UnavailabilityError","ServerRegistrationModule","addPushTokenListener","getDevicePushTokenAsync","updateDevicePushTokenAsync","updateDevicePushTokenAsyncWithSignal","lastAbortController","updatePushTokenAsync","_x","_updatePushTokenAsync","_asyncToGenerator","token","_lastAbortController","abort","AbortController","signal","apply","arguments","setAutoServerRegistrationEnabledAsync","_x2","_setAutoServerRegistrationEnabledAsync","enabled","_lastAbortController2","setRegistrationInfoAsync","JSON","stringify","isEnabled","__handlePersistedRegistrationInfoAsync","_x3","_handlePersistedRegistrationInfoAsync","registrationInfo","_registration","registration","parse","e","console","warn","latestDevicePushToken","getRegistrationInfoAsync","_ref","_x4","then"],"sources":["/Users/syndell-068/Documents/GitHub/colorhunt-reactnative-frontend/node_modules/expo-notifications/src/DevicePushTokenAutoRegistration.fx.ts"],"sourcesContent":["import 'abort-controller/polyfill';\nimport { UnavailabilityError } from 'expo-modules-core';\n\nimport ServerRegistrationModule from './ServerRegistrationModule';\nimport { addPushTokenListener } from './TokenEmitter';\nimport { DevicePushToken } from './Tokens.types';\nimport getDevicePushTokenAsync from './getDevicePushTokenAsync';\nimport { updateDevicePushTokenAsync as updateDevicePushTokenAsyncWithSignal } from './utils/updateDevicePushTokenAsync';\n\nlet lastAbortController: AbortController | null = null;\nasync function updatePushTokenAsync(token: DevicePushToken) {\n  // Abort current update process\n  lastAbortController?.abort();\n  lastAbortController = new AbortController();\n  return await updateDevicePushTokenAsyncWithSignal(lastAbortController.signal, token);\n}\n\n/**\n * Encapsulates device server registration data\n */\nexport type DevicePushTokenRegistration = {\n  isEnabled: boolean;\n};\n\n/**\n * Sets the registration information so that the device push token gets pushed\n * to the given registration endpoint\n * @param enabled\n */\nexport async function setAutoServerRegistrationEnabledAsync(enabled: boolean) {\n  // We are overwriting registration, so we shouldn't let\n  // any pending request complete.\n  lastAbortController?.abort();\n\n  if (!ServerRegistrationModule.setRegistrationInfoAsync) {\n    throw new UnavailabilityError('ServerRegistrationModule', 'setRegistrationInfoAsync');\n  }\n\n  await ServerRegistrationModule.setRegistrationInfoAsync(\n    enabled ? JSON.stringify({ isEnabled: enabled }) : null\n  );\n}\n\n// note(Chmiela): This function is exported only for testing purposes.\nexport async function __handlePersistedRegistrationInfoAsync(\n  registrationInfo: string | null | undefined\n) {\n  if (!registrationInfo) {\n    // No registration info, nothing to do\n    return;\n  }\n\n  let registration: DevicePushTokenRegistration | null = null;\n  try {\n    registration = JSON.parse(registrationInfo);\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while fetching registration information for auto token updates.',\n      e\n    );\n  }\n\n  if (!registration?.isEnabled) {\n    // Registration is invalid or not enabled, nothing more to do\n    return;\n  }\n\n  try {\n    // Since the registration is enabled, fetching a \"new\" device token\n    // shouldn't be a problem.\n    const latestDevicePushToken = await getDevicePushTokenAsync();\n    await updatePushTokenAsync(latestDevicePushToken);\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while updating server registration with latest device push token.',\n      e\n    );\n  }\n}\n\nif (ServerRegistrationModule.getRegistrationInfoAsync) {\n  // A global scope (to get all the updates) device push token\n  // subscription, never cleared.\n  addPushTokenListener(async (token) => {\n    try {\n      // Before updating the push token on server we always check if we should\n      // Since modules can't change their method availability while running, we\n      // can assert it's defined.\n      const registrationInfo = await ServerRegistrationModule.getRegistrationInfoAsync!();\n\n      if (!registrationInfo) {\n        // Registration is not enabled\n        return;\n      }\n\n      const registration: DevicePushTokenRegistration | null = JSON.parse(registrationInfo);\n      if (registration?.isEnabled) {\n        // Dispatch an abortable task to update\n        // registration with new token.\n        await updatePushTokenAsync(token);\n      }\n    } catch (e) {\n      console.warn(\n        '[expo-notifications] Error encountered while updating server registration with latest device push token.',\n        e\n      );\n    }\n  });\n\n  // Verify if persisted registration\n  // has successfully uploaded last known\n  // device push token. If not, retry.\n  ServerRegistrationModule.getRegistrationInfoAsync().then(__handlePersistedRegistrationInfoAsync);\n} else {\n  console.warn(\n    `[expo-notifications] Error encountered while fetching auto-registration state, new tokens will not be automatically registered on server.`,\n    new UnavailabilityError('ServerRegistrationModule', 'getRegistrationInfoAsync')\n  );\n}\n"],"mappings":";;AAAA,OAAO,2BAA2B;AAClC,SAASA,mBAAmB,QAAQ,mBAAmB;AAEvD,OAAOC,wBAAwB;AAC/B,SAASC,oBAAoB;AAE7B,OAAOC,uBAAuB;AAC9B,SAASC,0BAA0B,IAAIC,oCAAoC;AAE3E,IAAIC,mBAAmB,GAA2B,IAAI;AAAC,SACxCC,oBAAoBA,CAAAC,EAAA;EAAA,QAAAC,qBAAA,GAAAA,qBAAA,IAAAC,iBAAA,CAAnC,WAAoCC,KAAsB;IAAA,IAAAC,oBAAA;IAExD,CAAAA,oBAAA,GAAAN,mBAAmB,qBAAnBM,oBAAA,CAAqBC,KAAK,EAAE;IAC5BP,mBAAmB,GAAG,IAAIQ,eAAe,EAAE;IAC3C,aAAaT,oCAAoC,CAACC,mBAAmB,CAACS,MAAM,EAAEJ,KAAK,CAAC;EACtF,CAAC,GAAAK,KAAA,OAAAC,SAAA;AAAA;AAcD,gBAAsBC,qCAAqCA,CAAAC,GAAA;EAAA,QAAAC,sCAAA,GAAAA,sCAAA,IAAAV,iBAAA,CAApD,WAAqDW,OAAgB;IAAA,IAAAC,qBAAA;IAG1E,CAAAA,qBAAA,GAAAhB,mBAAmB,qBAAnBgB,qBAAA,CAAqBT,KAAK,EAAE;IAE5B,IAAI,CAACZ,wBAAwB,CAACsB,wBAAwB,EAAE;MACtD,MAAM,IAAIvB,mBAAmB,CAAC,0BAA0B,EAAE,0BAA0B,CAAC;;IAGvF,MAAMC,wBAAwB,CAACsB,wBAAwB,CACrDF,OAAO,GAAGG,IAAI,CAACC,SAAS,CAAC;MAAEC,SAAS,EAAEL;IAAO,CAAE,CAAC,GAAG,IAAI,CACxD;EACH,CAAC,GAAAL,KAAA,OAAAC,SAAA;AAAA;AAGD,gBAAsBU,sCAAsCA,CAAAC,GAAA;EAAA,QAAAC,qCAAA,GAAAA,qCAAA,IAAAnB,iBAAA,CAArD,WACLoB,gBAA2C;IAAA,IAAAC,aAAA;IAE3C,IAAI,CAACD,gBAAgB,EAAE;MAErB;;IAGF,IAAIE,YAAY,GAAuC,IAAI;IAC3D,IAAI;MACFA,YAAY,GAAGR,IAAI,CAACS,KAAK,CAACH,gBAAgB,CAAC;KAC5C,CAAC,OAAOI,CAAC,EAAE;MACVC,OAAO,CAACC,IAAI,CACV,wGAAwG,EACxGF,CAAC,CACF;;IAGH,IAAI,GAAAH,aAAA,GAACC,YAAY,aAAZD,aAAA,CAAcL,SAAS,GAAE;MAE5B;;IAGF,IAAI;MAGF,IAAMW,qBAAqB,SAASlC,uBAAuB,EAAE;MAC7D,MAAMI,oBAAoB,CAAC8B,qBAAqB,CAAC;KAClD,CAAC,OAAOH,CAAC,EAAE;MACVC,OAAO,CAACC,IAAI,CACV,0GAA0G,EAC1GF,CAAC,CACF;;EAEL,CAAC,GAAAlB,KAAA,OAAAC,SAAA;AAAA;AAED,IAAIhB,wBAAwB,CAACqC,wBAAwB,EAAE;EAAA,IAAAC,IAAA;EAGrDrC,oBAAoB,WAAAsC,GAAA;IAAA,QAAAD,IAAA,GAAAA,IAAA,IAAA7B,iBAAA,CAAC,WAAOC,KAAK,EAAI;MACnC,IAAI;QAIF,IAAMmB,gBAAgB,SAAS7B,wBAAwB,CAACqC,wBAAyB,EAAE;QAEnF,IAAI,CAACR,gBAAgB,EAAE;UAErB;;QAGF,IAAME,YAAY,GAAuCR,IAAI,CAACS,KAAK,CAACH,gBAAgB,CAAC;QACrF,IAAIE,YAAY,YAAZA,YAAY,CAAEN,SAAS,EAAE;UAG3B,MAAMnB,oBAAoB,CAACI,KAAK,CAAC;;OAEpC,CAAC,OAAOuB,CAAC,EAAE;QACVC,OAAO,CAACC,IAAI,CACV,0GAA0G,EAC1GF,CAAC,CACF;;IAEL,CAAC,GAAAlB,KAAA,OAAAC,SAAA;EAAA,EAAC;EAKFhB,wBAAwB,CAACqC,wBAAwB,EAAE,CAACG,IAAI,CAACd,sCAAsC,CAAC;CACjG,MAAM;EACLQ,OAAO,CAACC,IAAI,8IAEV,IAAIpC,mBAAmB,CAAC,0BAA0B,EAAE,0BAA0B,CAAC,CAChF"},"metadata":{},"sourceType":"module","externalDependencies":[]}