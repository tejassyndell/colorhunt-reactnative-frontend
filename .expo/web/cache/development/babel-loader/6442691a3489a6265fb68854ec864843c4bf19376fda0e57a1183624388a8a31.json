{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nvar _getExpoPushTokenAsync, _parseResponse, _getDeviceIdAsync, _shouldUseDevelopmentNotificationService;\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport * as Application from 'expo-application';\nimport Constants from 'expo-constants';\nimport { Platform, CodedError, UnavailabilityError } from 'expo-modules-core';\nimport { setAutoServerRegistrationEnabledAsync } from \"./DevicePushTokenAutoRegistration.fx\";\nimport ServerRegistrationModule from \"./ServerRegistrationModule\";\nimport getDevicePushTokenAsync from \"./getDevicePushTokenAsync\";\nvar productionBaseUrl = 'https://exp.host/--/api/v2/';\nexport default function getExpoPushTokenAsync() {\n  return (_getExpoPushTokenAsync = _getExpoPushTokenAsync || _asyncToGenerator(function* () {\n    var _Constants$expoConfig, _Constants$manifest, _Constants$expoConfig2, _Constants$expoConfig3, _Constants$expoConfig4, _Constants$manifest2, _options$baseUrl, _options$url;\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var devicePushToken = options.devicePushToken || (yield getDevicePushTokenAsync());\n    var deviceId = options.deviceId || (yield getDeviceIdAsync());\n    var experienceId = options.experienceId || ((_Constants$expoConfig = Constants.expoConfig) == null ? void 0 : _Constants$expoConfig.originalFullName) || ((_Constants$manifest = Constants.manifest) == null ? void 0 : _Constants$manifest.id);\n    var projectId = options.projectId || ((_Constants$expoConfig2 = Constants.expoConfig) == null ? void 0 : (_Constants$expoConfig3 = _Constants$expoConfig2.extra) == null ? void 0 : (_Constants$expoConfig4 = _Constants$expoConfig3.eas) == null ? void 0 : _Constants$expoConfig4.projectId) || ((_Constants$manifest2 = Constants.manifest) == null ? void 0 : _Constants$manifest2.projectId);\n    if (!projectId) {\n      console.warn('Calling getExpoPushTokenAsync without specifying a projectId is deprecated and will no longer be supported in SDK 49+');\n    }\n    if (!experienceId && !projectId) {\n      throw new CodedError('ERR_NOTIFICATIONS_NO_EXPERIENCE_ID', \"No experienceId or projectId found. If one or the other can't be inferred from the manifest (eg. in bare workflow), you have to pass one in yourself.\");\n    }\n    var applicationId = options.applicationId || Application.applicationId;\n    if (!applicationId) {\n      throw new CodedError('ERR_NOTIFICATIONS_NO_APPLICATION_ID', \"No applicationId found. If it can't be inferred from native configuration by expo-application, you have to pass it in yourself.\");\n    }\n    var type = options.type || getTypeOfToken(devicePushToken);\n    var development = options.development || (yield shouldUseDevelopmentNotificationService());\n    var baseUrl = (_options$baseUrl = options.baseUrl) != null ? _options$baseUrl : productionBaseUrl;\n    var url = (_options$url = options.url) != null ? _options$url : baseUrl + \"push/getExpoPushToken\";\n    var body = _objectSpread({\n      type: type,\n      deviceId: deviceId.toLowerCase(),\n      development: development,\n      appId: applicationId,\n      deviceToken: getDeviceToken(devicePushToken)\n    }, projectId ? {\n      projectId: projectId\n    } : {\n      experienceId: experienceId\n    });\n    var response = yield fetch(url, {\n      method: 'POST',\n      headers: {\n        'content-type': 'application/json'\n      },\n      body: JSON.stringify(body)\n    }).catch(function (error) {\n      throw new CodedError('ERR_NOTIFICATIONS_NETWORK_ERROR', \"Error encountered while fetching Expo token: \" + error + \".\");\n    });\n    if (!response.ok) {\n      var statusInfo = response.statusText || response.status;\n      var _body = undefined;\n      try {\n        _body = yield response.text();\n      } catch (_unused) {}\n      throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR', \"Error encountered while fetching Expo token, expected an OK response, received: \" + statusInfo + \" (body: \\\"\" + _body + \"\\\").\");\n    }\n    var expoPushToken = getExpoPushToken(yield parseResponse(response));\n    try {\n      if (options.url || options.baseUrl) {\n        console.debug(\"[expo-notifications] Since the URL endpoint to register in has been customized in the options, expo-notifications won't try to auto-update the device push token on the server.\");\n      } else {\n        yield setAutoServerRegistrationEnabledAsync(true);\n      }\n    } catch (e) {\n      console.warn('[expo-notifications] Could not enable automatically registering new device tokens with the Expo notification service', e);\n    }\n    return {\n      type: 'expo',\n      data: expoPushToken\n    };\n  })).apply(this, arguments);\n}\nfunction parseResponse(_x) {\n  return (_parseResponse = _parseResponse || _asyncToGenerator(function* (response) {\n    try {\n      return yield response.json();\n    } catch (_unused2) {\n      try {\n        throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR', \"Expected a JSON response from server when fetching Expo token, received body: \" + JSON.stringify(yield response.text()) + \".\");\n      } catch (_unused3) {\n        throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR', \"Expected a JSON response from server when fetching Expo token, received response: \" + JSON.stringify(response) + \".\");\n      }\n    }\n  })).apply(this, arguments);\n}\nfunction getExpoPushToken(data) {\n  if (!data || !(typeof data === 'object') || !data.data || !(typeof data.data === 'object') || !data.data.expoPushToken || !(typeof data.data.expoPushToken === 'string')) {\n    throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR', \"Malformed response from server, expected \\\"{ data: { expoPushToken: string } }\\\", received: \" + JSON.stringify(data, null, 2) + \".\");\n  }\n  return data.data.expoPushToken;\n}\nfunction getDeviceIdAsync() {\n  return (_getDeviceIdAsync = _getDeviceIdAsync || _asyncToGenerator(function* () {\n    try {\n      if (!ServerRegistrationModule.getInstallationIdAsync) {\n        throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n      }\n      return yield ServerRegistrationModule.getInstallationIdAsync();\n    } catch (e) {\n      throw new CodedError('ERR_NOTIF_DEVICE_ID', \"Could not have fetched installation ID of the application: \" + e + \".\");\n    }\n  })).apply(this, arguments);\n}\nfunction getDeviceToken(devicePushToken) {\n  if (typeof devicePushToken.data === 'string') {\n    return devicePushToken.data;\n  }\n  return JSON.stringify(devicePushToken.data);\n}\nfunction shouldUseDevelopmentNotificationService() {\n  return (_shouldUseDevelopmentNotificationService = _shouldUseDevelopmentNotificationService || _asyncToGenerator(function* () {\n    if (Platform.OS === 'ios') {\n      try {\n        var notificationServiceEnvironment = yield Application.getIosPushNotificationServiceEnvironmentAsync();\n        if (notificationServiceEnvironment === 'development') {\n          return true;\n        }\n      } catch (_unused4) {}\n    }\n    return false;\n  })).apply(this, arguments);\n}\nfunction getTypeOfToken(devicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    default:\n      return devicePushToken.type;\n  }\n}","map":{"version":3,"names":["Application","Constants","Platform","CodedError","UnavailabilityError","setAutoServerRegistrationEnabledAsync","ServerRegistrationModule","getDevicePushTokenAsync","productionBaseUrl","getExpoPushTokenAsync","_getExpoPushTokenAsync","_asyncToGenerator","_Constants$expoConfig","_Constants$manifest","_Constants$expoConfig2","_Constants$expoConfig3","_Constants$expoConfig4","_Constants$manifest2","_options$baseUrl","_options$url","options","arguments","length","undefined","devicePushToken","deviceId","getDeviceIdAsync","experienceId","expoConfig","originalFullName","manifest","id","projectId","extra","eas","console","warn","applicationId","type","getTypeOfToken","development","shouldUseDevelopmentNotificationService","baseUrl","url","body","_objectSpread","toLowerCase","appId","deviceToken","getDeviceToken","response","fetch","method","headers","JSON","stringify","catch","error","ok","statusInfo","statusText","status","text","_unused","expoPushToken","getExpoPushToken","parseResponse","debug","e","data","apply","_x","_parseResponse","json","_unused2","_unused3","_getDeviceIdAsync","getInstallationIdAsync","_shouldUseDevelopmentNotificationService","OS","notificationServiceEnvironment","getIosPushNotificationServiceEnvironmentAsync","_unused4"],"sources":["/Users/syndell-068/Documents/GitHub/colorhunt-reactnative-frontend/node_modules/expo-notifications/src/getExpoPushTokenAsync.ts"],"sourcesContent":["import * as Application from 'expo-application';\nimport Constants from 'expo-constants';\nimport { Platform, CodedError, UnavailabilityError } from 'expo-modules-core';\n\nimport { setAutoServerRegistrationEnabledAsync } from './DevicePushTokenAutoRegistration.fx';\nimport ServerRegistrationModule from './ServerRegistrationModule';\nimport { DevicePushToken, ExpoPushToken, ExpoPushTokenOptions } from './Tokens.types';\nimport getDevicePushTokenAsync from './getDevicePushTokenAsync';\n\nconst productionBaseUrl = 'https://exp.host/--/api/v2/';\n\n/**\n * Returns an Expo token that can be used to send a push notification to the device using Expo's push notifications service.\n *\n * This method makes requests to the Expo's servers. It can get rejected in cases where the request itself fails\n * (for example, due to the device being offline, experiencing a network timeout, or other HTTPS request failures).\n * To provide offline support to your users, you should `try/catch` this method and implement retry logic to attempt\n * to get the push token later, once the device is back online.\n *\n * > For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys.\n * For more information, see [credentials](/push-notifications/push-notifications-setup/#get-credentials-for-development-builds) in the push notifications setup.\n *\n * @param options Object allowing you to pass in push notification configuration.\n * @return Returns a `Promise` that resolves to an object representing acquired push token.\n * @header fetch\n *\n * @example\n * ```ts\n * import * as Notifications from 'expo-notifications';\n *\n * export async function registerForPushNotificationsAsync(userId: string) {\n *   const expoPushToken = await Notifications.getExpoPushTokenAsync({\n *    projectId: 'your-project-id',\n *   });\n *\n *   await fetch('https://example.com/', {\n *     method: 'POST',\n *     headers: {\n *       'Content-Type': 'application/json',\n *     },\n *     body: JSON.stringify({\n *       userId,\n *       expoPushToken,\n *     }),\n *   });\n * }\n * ```\n */\nexport default async function getExpoPushTokenAsync(\n  options: ExpoPushTokenOptions = {}\n): Promise<ExpoPushToken> {\n  const devicePushToken = options.devicePushToken || (await getDevicePushTokenAsync());\n\n  const deviceId = options.deviceId || (await getDeviceIdAsync());\n\n  const experienceId =\n    options.experienceId || Constants.expoConfig?.originalFullName || Constants.manifest?.id;\n\n  const projectId =\n    options.projectId ||\n    Constants.expoConfig?.extra?.eas?.projectId ||\n    Constants.manifest?.projectId;\n\n  if (!projectId) {\n    console.warn(\n      'Calling getExpoPushTokenAsync without specifying a projectId is deprecated and will no longer be supported in SDK 49+'\n    );\n  }\n\n  if (!experienceId && !projectId) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NO_EXPERIENCE_ID',\n      \"No experienceId or projectId found. If one or the other can't be inferred from the manifest (eg. in bare workflow), you have to pass one in yourself.\"\n    );\n  }\n\n  const applicationId = options.applicationId || Application.applicationId;\n  if (!applicationId) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NO_APPLICATION_ID',\n      \"No applicationId found. If it can't be inferred from native configuration by expo-application, you have to pass it in yourself.\"\n    );\n  }\n  const type = options.type || getTypeOfToken(devicePushToken);\n  const development = options.development || (await shouldUseDevelopmentNotificationService());\n\n  const baseUrl = options.baseUrl ?? productionBaseUrl;\n  const url = options.url ?? `${baseUrl}push/getExpoPushToken`;\n\n  const body = {\n    type,\n    deviceId: deviceId.toLowerCase(),\n    development,\n    appId: applicationId,\n    deviceToken: getDeviceToken(devicePushToken),\n    ...(projectId ? { projectId } : { experienceId }),\n  };\n\n  const response = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'content-type': 'application/json',\n    },\n    body: JSON.stringify(body),\n  }).catch((error) => {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NETWORK_ERROR',\n      `Error encountered while fetching Expo token: ${error}.`\n    );\n  });\n\n  if (!response.ok) {\n    const statusInfo = response.statusText || response.status;\n    let body: string | undefined = undefined;\n    try {\n      body = await response.text();\n    } catch {\n      // do nothing\n    }\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_SERVER_ERROR',\n      `Error encountered while fetching Expo token, expected an OK response, received: ${statusInfo} (body: \"${body}\").`\n    );\n  }\n\n  const expoPushToken = getExpoPushToken(await parseResponse(response));\n\n  try {\n    if (options.url || options.baseUrl) {\n      console.debug(\n        `[expo-notifications] Since the URL endpoint to register in has been customized in the options, expo-notifications won't try to auto-update the device push token on the server.`\n      );\n    } else {\n      await setAutoServerRegistrationEnabledAsync(true);\n    }\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Could not enable automatically registering new device tokens with the Expo notification service',\n      e\n    );\n  }\n\n  return {\n    type: 'expo',\n    data: expoPushToken,\n  };\n}\n\nasync function parseResponse(response: Response) {\n  try {\n    return await response.json();\n  } catch {\n    try {\n      throw new CodedError(\n        'ERR_NOTIFICATIONS_SERVER_ERROR',\n        `Expected a JSON response from server when fetching Expo token, received body: ${JSON.stringify(\n          await response.text()\n        )}.`\n      );\n    } catch {\n      throw new CodedError(\n        'ERR_NOTIFICATIONS_SERVER_ERROR',\n        `Expected a JSON response from server when fetching Expo token, received response: ${JSON.stringify(\n          response\n        )}.`\n      );\n    }\n  }\n}\n\nfunction getExpoPushToken(data: any) {\n  if (\n    !data ||\n    !(typeof data === 'object') ||\n    !data.data ||\n    !(typeof data.data === 'object') ||\n    !data.data.expoPushToken ||\n    !(typeof data.data.expoPushToken === 'string')\n  ) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_SERVER_ERROR',\n      `Malformed response from server, expected \"{ data: { expoPushToken: string } }\", received: ${JSON.stringify(\n        data,\n        null,\n        2\n      )}.`\n    );\n  }\n\n  return data.data.expoPushToken as string;\n}\n\n// Same as in DevicePushTokenAutoRegistration\nasync function getDeviceIdAsync() {\n  try {\n    if (!ServerRegistrationModule.getInstallationIdAsync) {\n      throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n    }\n\n    return await ServerRegistrationModule.getInstallationIdAsync();\n  } catch (e) {\n    throw new CodedError(\n      'ERR_NOTIF_DEVICE_ID',\n      `Could not have fetched installation ID of the application: ${e}.`\n    );\n  }\n}\n\nfunction getDeviceToken(devicePushToken: DevicePushToken) {\n  if (typeof devicePushToken.data === 'string') {\n    return devicePushToken.data;\n  }\n\n  return JSON.stringify(devicePushToken.data);\n}\n\n// Same as in DevicePushTokenAutoRegistration\nasync function shouldUseDevelopmentNotificationService() {\n  if (Platform.OS === 'ios') {\n    try {\n      const notificationServiceEnvironment =\n        await Application.getIosPushNotificationServiceEnvironmentAsync();\n      if (notificationServiceEnvironment === 'development') {\n        return true;\n      }\n    } catch {\n      // We can't do anything here, we'll fallback to false then.\n    }\n  }\n\n  return false;\n}\n\n// Same as in DevicePushTokenAutoRegistration\nfunction getTypeOfToken(devicePushToken: DevicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    // This probably will error on server, but let's make this function future-safe.\n    default:\n      return devicePushToken.type;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}